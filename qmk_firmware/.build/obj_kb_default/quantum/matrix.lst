   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE10:
  26               		.section	.text.matrix_init_kb,"ax",@progbits
  27               		.weak	matrix_init_kb
  29               	matrix_init_kb:
  30               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  31               		.loc 1 98 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  37               		.loc 1 99 0
  38 0000 0C94 0000 		jmp matrix_init_user
  39               	.LVL0:
  40               		.cfi_endproc
  41               	.LFE8:
  43               		.section	.text.matrix_init_quantum,"ax",@progbits
  44               		.weak	matrix_init_quantum
  46               	matrix_init_quantum:
  47               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  48               		.loc 1 88 0
  49               		.cfi_startproc
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  54               		.loc 1 89 0
  55 0000 0C94 0000 		jmp matrix_init_kb
  56               	.LVL1:
  57               		.cfi_endproc
  58               	.LFE6:
  60               		.section	.text.matrix_scan_user,"ax",@progbits
  61               		.weak	matrix_scan_user
  63               	matrix_scan_user:
  64               	.LFB11:
 109:quantum/matrix.c **** }
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  65               		.loc 1 112 0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  71 0000 0895      		ret
  72               		.cfi_endproc
  73               	.LFE11:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  80               		.loc 1 103 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  86               		.loc 1 104 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE9:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
  97               		.loc 1 93 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 103               		.loc 1 94 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE7:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB12:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 114               		.loc 1 116 0
 115               		.cfi_startproc
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 120               		.loc 1 118 0
 121 0000 85E0      		ldi r24,lo8(5)
 122 0002 0895      		ret
 123               		.cfi_endproc
 124               	.LFE12:
 126               		.section	.text.matrix_cols,"ax",@progbits
 127               	.global	matrix_cols
 129               	matrix_cols:
 130               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 131               		.loc 1 121 0
 132               		.cfi_startproc
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 137               		.loc 1 123 0
 138 0000 84E0      		ldi r24,lo8(4)
 139 0002 0895      		ret
 140               		.cfi_endproc
 141               	.LFE13:
 143               		.section	.text.matrix_init,"ax",@progbits
 144               	.global	matrix_init
 146               	matrix_init:
 147               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 148               		.loc 1 149 0
 149               		.cfi_startproc
 150 0000 CF93      		push r28
 151               	.LCFI0:
 152               		.cfi_def_cfa_offset 3
 153               		.cfi_offset 28, -2
 154 0002 DF93      		push r29
 155               	.LCFI1:
 156               		.cfi_def_cfa_offset 4
 157               		.cfi_offset 29, -3
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 2 */
 161               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 162               		.loc 1 153 0
 163 0004 85B7      		in r24,0x35
 164 0006 8068      		ori r24,lo8(-128)
 165 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 166               		.loc 1 154 0
 167 000a 85B7      		in r24,0x35
 168 000c 8068      		ori r24,lo8(-128)
 169 000e 85BF      		out 0x35,r24
 170               	.LVL4:
 171 0010 A0E0      		ldi r26,lo8(row_pins)
 172 0012 B0E0      		ldi r27,hi8(row_pins)
 173               	.LBB19:
 174               	.LBB20:
 175               	.LBB21:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 176               		.loc 1 334 0
 177 0014 41E0      		ldi r20,lo8(1)
 178 0016 50E0      		ldi r21,0
 179 0018 25E0      		ldi r18,lo8(5)
 180 001a 2A0F      		add r18,r26
 181               	.LVL5:
 182               	.L10:
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 183               		.loc 1 333 0
 184 001c 8D91      		ld r24,X+
 185               	.LVL6:
 186               		.loc 1 334 0
 187 001e E82F      		mov r30,r24
 188 0020 E295      		swap r30
 189 0022 EF70      		andi r30,lo8(15)
 190 0024 F0E0      		ldi r31,0
 191 0026 31A1      		ldd r19,Z+33
 192 0028 8F70      		andi r24,lo8(15)
 193               	.LVL7:
 194 002a BA01      		movw r22,r20
 195 002c 00C0      		rjmp 2f
 196               		1:
 197 002e 660F      		lsl r22
 198 0030 771F      		rol r23
 199               		2:
 200 0032 8A95      		dec r24
 201 0034 02F4      		brpl 1b
 202 0036 CB01      		movw r24,r22
 203 0038 962F      		mov r25,r22
 204 003a 9095      		com r25
 205 003c 9323      		and r25,r19
 206 003e 91A3      		std Z+33,r25
 207               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 208               		.loc 1 335 0
 209 0040 92A1      		ldd r25,Z+34
 210 0042 892B      		or r24,r25
 211 0044 82A3      		std Z+34,r24
 212               	.LVL9:
 213               	.LBE21:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 214               		.loc 1 332 0
 215 0046 2A13      		cpse r18,r26
 216 0048 00C0      		rjmp .L10
 217 004a A0E0      		ldi r26,lo8(col_pins)
 218 004c B0E0      		ldi r27,hi8(col_pins)
 219               	.LVL10:
 220               	.LBE20:
 221               	.LBE19:
 222               	.LBB22:
 223               	.LBB23:
 224               	.LBB24:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 225               		.loc 1 282 0
 226 004e 41E0      		ldi r20,lo8(1)
 227 0050 50E0      		ldi r21,0
 228 0052 24E0      		ldi r18,lo8(4)
 229 0054 2A0F      		add r18,r26
 230               	.L11:
 231               	.LVL11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 232               		.loc 1 281 0
 233 0056 8D91      		ld r24,X+
 234               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 235               		.loc 1 282 0
 236 0058 E82F      		mov r30,r24
 237 005a E295      		swap r30
 238 005c EF70      		andi r30,lo8(15)
 239 005e F0E0      		ldi r31,0
 240 0060 31A1      		ldd r19,Z+33
 241 0062 8F70      		andi r24,lo8(15)
 242               	.LVL13:
 243 0064 BA01      		movw r22,r20
 244 0066 00C0      		rjmp 2f
 245               		1:
 246 0068 660F      		lsl r22
 247 006a 771F      		rol r23
 248               		2:
 249 006c 8A95      		dec r24
 250 006e 02F4      		brpl 1b
 251 0070 CB01      		movw r24,r22
 252 0072 962F      		mov r25,r22
 253 0074 9095      		com r25
 254 0076 9323      		and r25,r19
 255 0078 91A3      		std Z+33,r25
 256               	.LVL14:
 283:quantum/matrix.c ****     }
 257               		.loc 1 283 0
 258 007a 92A1      		ldd r25,Z+34
 259 007c 892B      		or r24,r25
 260 007e 82A3      		std Z+34,r24
 261               	.LVL15:
 262               	.LBE24:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 263               		.loc 1 280 0
 264 0080 2A13      		cpse r18,r26
 265 0082 00C0      		rjmp .L11
 266 0084 C0E0      		ldi r28,lo8(matrix_raw)
 267 0086 D0E0      		ldi r29,hi8(matrix_raw)
 268 0088 A0E0      		ldi r26,lo8(matrix_debouncing)
 269 008a B0E0      		ldi r27,hi8(matrix_debouncing)
 270               	.LVL16:
 271 008c E0E0      		ldi r30,lo8(matrix)
 272 008e F0E0      		ldi r31,hi8(matrix)
 273 0090 85E0      		ldi r24,lo8(5)
 274 0092 8E0F      		add r24,r30
 275               	.L12:
 276               	.LVL17:
 277               	.LBE23:
 278               	.LBE22:
 279               	.LBB25:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 280               		.loc 1 168 0 discriminator 3
 281 0094 1192      		st Z+,__zero_reg__
 282               	.LVL18:
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 283               		.loc 1 169 0 discriminator 3
 284 0096 1992      		st Y+,__zero_reg__
 170:quantum/matrix.c ****     }
 285               		.loc 1 170 0 discriminator 3
 286 0098 1D92      		st X+,__zero_reg__
 287               	.LVL19:
 167:quantum/matrix.c ****         matrix[i] = 0;
 288               		.loc 1 167 0 discriminator 3
 289 009a 8E13      		cpse r24,r30
 290 009c 00C0      		rjmp .L12
 291               	/* epilogue start */
 292               	.LBE25:
 174:quantum/matrix.c **** 
 293               		.loc 1 174 0
 294 009e DF91      		pop r29
 295 00a0 CF91      		pop r28
 173:quantum/matrix.c **** }
 296               		.loc 1 173 0
 297 00a2 0C94 0000 		jmp matrix_init_quantum
 298               	.LVL20:
 299               		.cfi_endproc
 300               	.LFE14:
 302               		.section	.text.matrix_scan,"ax",@progbits
 303               	.global	matrix_scan
 305               	matrix_scan:
 306               	.LFB15:
 177:quantum/matrix.c **** 
 307               		.loc 1 177 0
 308               		.cfi_startproc
 309 0000 2F92      		push r2
 310               	.LCFI2:
 311               		.cfi_def_cfa_offset 3
 312               		.cfi_offset 2, -2
 313 0002 3F92      		push r3
 314               	.LCFI3:
 315               		.cfi_def_cfa_offset 4
 316               		.cfi_offset 3, -3
 317 0004 5F92      		push r5
 318               	.LCFI4:
 319               		.cfi_def_cfa_offset 5
 320               		.cfi_offset 5, -4
 321 0006 6F92      		push r6
 322               	.LCFI5:
 323               		.cfi_def_cfa_offset 6
 324               		.cfi_offset 6, -5
 325 0008 7F92      		push r7
 326               	.LCFI6:
 327               		.cfi_def_cfa_offset 7
 328               		.cfi_offset 7, -6
 329 000a 8F92      		push r8
 330               	.LCFI7:
 331               		.cfi_def_cfa_offset 8
 332               		.cfi_offset 8, -7
 333 000c 9F92      		push r9
 334               	.LCFI8:
 335               		.cfi_def_cfa_offset 9
 336               		.cfi_offset 9, -8
 337 000e AF92      		push r10
 338               	.LCFI9:
 339               		.cfi_def_cfa_offset 10
 340               		.cfi_offset 10, -9
 341 0010 BF92      		push r11
 342               	.LCFI10:
 343               		.cfi_def_cfa_offset 11
 344               		.cfi_offset 11, -10
 345 0012 CF92      		push r12
 346               	.LCFI11:
 347               		.cfi_def_cfa_offset 12
 348               		.cfi_offset 12, -11
 349 0014 DF92      		push r13
 350               	.LCFI12:
 351               		.cfi_def_cfa_offset 13
 352               		.cfi_offset 13, -12
 353 0016 EF92      		push r14
 354               	.LCFI13:
 355               		.cfi_def_cfa_offset 14
 356               		.cfi_offset 14, -13
 357 0018 FF92      		push r15
 358               	.LCFI14:
 359               		.cfi_def_cfa_offset 15
 360               		.cfi_offset 15, -14
 361 001a 0F93      		push r16
 362               	.LCFI15:
 363               		.cfi_def_cfa_offset 16
 364               		.cfi_offset 16, -15
 365 001c 1F93      		push r17
 366               	.LCFI16:
 367               		.cfi_def_cfa_offset 17
 368               		.cfi_offset 17, -16
 369 001e CF93      		push r28
 370               	.LCFI17:
 371               		.cfi_def_cfa_offset 18
 372               		.cfi_offset 28, -17
 373 0020 DF93      		push r29
 374               	.LCFI18:
 375               		.cfi_def_cfa_offset 19
 376               		.cfi_offset 29, -18
 377               	/* prologue: function */
 378               	/* frame size = 0 */
 379               	/* stack size = 17 */
 380               	.L__stack_usage = 17
 381               	.LVL21:
 382 0022 20E0      		ldi r18,lo8(row_pins)
 383 0024 C22E      		mov r12,r18
 384 0026 20E0      		ldi r18,hi8(row_pins)
 385 0028 D22E      		mov r13,r18
 386 002a 00E0      		ldi r16,lo8(matrix_debouncing)
 387 002c 10E0      		ldi r17,hi8(matrix_debouncing)
 177:quantum/matrix.c **** 
 388               		.loc 1 177 0
 389 002e E801      		movw r28,r16
 390               	.LBB39:
 391               	.LBB40:
 392               	.LBB41:
 393               	.LBB42:
 394               	.LBB43:
 395               	.LBB44:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 396               		.loc 1 319 0
 397 0030 EE24      		clr r14
 398 0032 E394      		inc r14
 399 0034 F12C      		mov r15,__zero_reg__
 400               	.LBE44:
 401               	.LBE43:
 402               	.LBE42:
 403               	.LBE41:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 404               		.loc 1 187 0
 405 0036 AA24      		clr r10
 406 0038 A394      		inc r10
 407 003a 45E0      		ldi r20,lo8(5)
 408 003c B42E      		mov r11,r20
 409 003e B00E      		add r11,r16
 410               	.LVL22:
 411               	.L21:
 412 0040 BE01      		movw r22,r28
 413               	.LBB54:
 414               	.LBB53:
 290:quantum/matrix.c **** 
 415               		.loc 1 290 0
 416 0042 8880      		ld r8,Y
 417               	.LVL23:
 293:quantum/matrix.c **** 
 418               		.loc 1 293 0
 419 0044 1882      		st Y,__zero_reg__
 420               	.LVL24:
 421               	.LBB46:
 422               	.LBB45:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 423               		.loc 1 318 0
 424 0046 D601      		movw r26,r12
 425 0048 8D91      		ld r24,X+
 426 004a 6D01      		movw r12,r26
 427               	.LVL25:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 428               		.loc 1 319 0
 429 004c E82F      		mov r30,r24
 430 004e E295      		swap r30
 431 0050 EF70      		andi r30,lo8(15)
 432 0052 F0E0      		ldi r31,0
 433 0054 21A1      		ldd r18,Z+33
 434 0056 8F70      		andi r24,lo8(15)
 435               	.LVL26:
 436 0058 A701      		movw r20,r14
 437 005a 00C0      		rjmp 2f
 438               		1:
 439 005c 440F      		lsl r20
 440 005e 551F      		rol r21
 441               		2:
 442 0060 8A95      		dec r24
 443 0062 02F4      		brpl 1b
 444 0064 CA01      		movw r24,r20
 445 0066 242B      		or r18,r20
 446 0068 21A3      		std Z+33,r18
 447               	.LVL27:
 320:quantum/matrix.c **** }
 448               		.loc 1 320 0
 449 006a 22A1      		ldd r18,Z+34
 450 006c 942E      		mov r9,r20
 451 006e 9094      		com r9
 452 0070 2921      		and r18,r9
 453 0072 22A3      		std Z+34,r18
 454               	.LVL28:
 455               	.LBE45:
 456               	.LBE46:
 457               	.LBB47:
 458               	.LBB48:
 459               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 460               		.loc 2 245 0
 461 0074 50EA      		ldi r21,lo8(-96)
 462 0076 5A95      	1:	dec r21
 463 0078 01F4      		brne 1b
 464               	.LVL29:
 465 007a 90E0      		ldi r25,lo8(col_pins)
 466 007c 292E      		mov r2,r25
 467 007e 90E0      		ldi r25,hi8(col_pins)
 468 0080 392E      		mov r3,r25
 469 0082 20E0      		ldi r18,0
 470 0084 30E0      		ldi r19,0
 471               	.LVL30:
 472               	.L19:
 473               	.LBE48:
 474               	.LBE47:
 475               	.LBB49:
 476               	.LBB50:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 477               		.loc 1 303 0
 478 0086 D101      		movw r26,r2
 479 0088 7D90      		ld r7,X+
 480 008a 1D01      		movw r2,r26
 481               	.LVL31:
 304:quantum/matrix.c **** 
 482               		.loc 1 304 0
 483 008c 472D      		mov r20,r7
 484 008e 4295      		swap r20
 485 0090 4F70      		andi r20,lo8(15)
 486 0092 50E0      		ldi r21,0
 487 0094 DA01      		movw r26,r20
 488 0096 9096      		adiw r26,32
 489 0098 5C90      		ld r5,X
 490               	.LVL32:
 307:quantum/matrix.c ****     }
 491               		.loc 1 307 0
 492 009a 6880      		ld r6,Y
 304:quantum/matrix.c **** 
 493               		.loc 1 304 0
 494 009c 572D      		mov r21,r7
 495 009e 5F70      		andi r21,lo8(15)
 496               	.LVL33:
 497 00a0 D701      		movw r26,r14
 498 00a2 00C0      		rjmp 2f
 499               		1:
 500 00a4 AA0F      		lsl r26
 501 00a6 BB1F      		rol r27
 502               		2:
 503 00a8 5A95      		dec r21
 504 00aa 02F4      		brpl 1b
 505 00ac AD01      		movw r20,r26
 506 00ae 4521      		and r20,r5
 307:quantum/matrix.c ****     }
 507               		.loc 1 307 0
 508 00b0 01F4      		brne .L26
 509 00b2 4E2D      		mov r20,r14
 510 00b4 022E      		mov r0,r18
 511 00b6 00C0      		rjmp 2f
 512               		1:
 513 00b8 440F      		lsl r20
 514               		2:
 515 00ba 0A94      		dec r0
 516 00bc 02F4      		brpl 1b
 517 00be 00C0      		rjmp .L18
 518               	.L26:
 519 00c0 40E0      		ldi r20,0
 520               	.L18:
 521 00c2 4629      		or r20,r6
 522 00c4 4883      		st Y,r20
 523               	.LVL34:
 524 00c6 2F5F      		subi r18,-1
 525 00c8 3F4F      		sbci r19,-1
 526               	.LVL35:
 527               	.LBE50:
 300:quantum/matrix.c **** 
 528               		.loc 1 300 0
 529 00ca 2430      		cpi r18,4
 530 00cc 3105      		cpc r19,__zero_reg__
 531 00ce 01F4      		brne .L19
 532               	.LVL36:
 533               	.LBE49:
 534               	.LBB51:
 535               	.LBB52:
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 536               		.loc 1 326 0
 537 00d0 91A1      		ldd r25,Z+33
 538 00d2 9922      		and r9,r25
 539 00d4 91A2      		std Z+33,r9
 327:quantum/matrix.c **** }
 540               		.loc 1 327 0
 541 00d6 92A1      		ldd r25,Z+34
 542 00d8 892B      		or r24,r25
 543 00da 82A3      		std Z+34,r24
 544 00dc 2196      		adiw r28,1
 545               	.LVL37:
 546               	.LBE52:
 547               	.LBE51:
 548               	.LBE53:
 549               	.LBE54:
 186:quantum/matrix.c ****                 debouncing = true;
 550               		.loc 1 186 0
 551 00de FB01      		movw r30,r22
 552 00e0 8081      		ld r24,Z
 553 00e2 8816      		cp r8,r24
 554 00e4 01F0      		breq .L20
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 555               		.loc 1 187 0
 556 00e6 A092 0000 		sts debouncing,r10
 188:quantum/matrix.c ****             }
 557               		.loc 1 188 0
 558 00ea 0E94 0000 		call timer_read
 559               	.LVL38:
 560 00ee 9093 0000 		sts debouncing_time+1,r25
 561 00f2 8093 0000 		sts debouncing_time,r24
 562               	.L20:
 563               	.LVL39:
 564               	.LBE40:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 565               		.loc 1 182 0 discriminator 2
 566 00f6 BC12      		cpse r11,r28
 567 00f8 00C0      		rjmp .L21
 568               	.LBE39:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 569               		.loc 1 216 0
 570 00fa 8091 0000 		lds r24,debouncing
 571 00fe 8823      		tst r24
 572 0100 01F0      		breq .L23
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 573               		.loc 1 216 0 is_stmt 0 discriminator 1
 574 0102 8091 0000 		lds r24,debouncing_time
 575 0106 9091 0000 		lds r25,debouncing_time+1
 576 010a 0E94 0000 		call timer_elapsed
 577               	.LVL40:
 578 010e 0697      		sbiw r24,6
 579 0110 00F0      		brlo .L23
 580 0112 E0E0      		ldi r30,lo8(matrix)
 581 0114 F0E0      		ldi r31,hi8(matrix)
 582               	.L25:
 583               	.LVL41:
 584               	.LBB55:
 218:quantum/matrix.c ****             }
 585               		.loc 1 218 0 is_stmt 1 discriminator 3
 586 0116 D801      		movw r26,r16
 587 0118 8D91      		ld r24,X+
 588 011a 8D01      		movw r16,r26
 589               	.LVL42:
 590 011c 8193      		st Z+,r24
 591               	.LVL43:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 592               		.loc 1 217 0 discriminator 3
 593 011e BA12      		cpse r11,r26
 594 0120 00C0      		rjmp .L25
 595               	.LBE55:
 220:quantum/matrix.c ****         }
 596               		.loc 1 220 0
 597 0122 1092 0000 		sts debouncing,__zero_reg__
 598               	.LVL44:
 599               	.L23:
 224:quantum/matrix.c ****     return 1;
 600               		.loc 1 224 0
 601 0126 0E94 0000 		call matrix_scan_quantum
 602               	.LVL45:
 226:quantum/matrix.c **** 
 603               		.loc 1 226 0
 604 012a 81E0      		ldi r24,lo8(1)
 605               	/* epilogue start */
 606 012c DF91      		pop r29
 607 012e CF91      		pop r28
 608               	.LVL46:
 609 0130 1F91      		pop r17
 610 0132 0F91      		pop r16
 611 0134 FF90      		pop r15
 612 0136 EF90      		pop r14
 613 0138 DF90      		pop r13
 614 013a CF90      		pop r12
 615 013c BF90      		pop r11
 616 013e AF90      		pop r10
 617 0140 9F90      		pop r9
 618 0142 8F90      		pop r8
 619               	.LVL47:
 620 0144 7F90      		pop r7
 621               	.LVL48:
 622 0146 6F90      		pop r6
 623 0148 5F90      		pop r5
 624 014a 3F90      		pop r3
 625 014c 2F90      		pop r2
 626 014e 0895      		ret
 627               		.cfi_endproc
 628               	.LFE15:
 630               		.section	.text.matrix_is_modified,"ax",@progbits
 631               	.global	matrix_is_modified
 633               	matrix_is_modified:
 634               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 635               		.loc 1 229 0
 636               		.cfi_startproc
 637               	/* prologue: function */
 638               	/* frame size = 0 */
 639               	/* stack size = 0 */
 640               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 641               		.loc 1 231 0
 642 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 643               		.loc 1 234 0
 644 0004 81E0      		ldi r24,lo8(1)
 645 0006 8927      		eor r24,r25
 646 0008 0895      		ret
 647               		.cfi_endproc
 648               	.LFE16:
 650               		.section	.text.matrix_is_on,"ax",@progbits
 651               	.global	matrix_is_on
 653               	matrix_is_on:
 654               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 655               		.loc 1 238 0
 656               		.cfi_startproc
 657               	.LVL49:
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 0 */
 661               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 662               		.loc 1 239 0
 663 0000 E82F      		mov r30,r24
 664 0002 F0E0      		ldi r31,0
 665 0004 E050      		subi r30,lo8(-(matrix))
 666 0006 F040      		sbci r31,hi8(-(matrix))
 667 0008 8081      		ld r24,Z
 668               	.LVL50:
 669 000a 282F      		mov r18,r24
 670 000c 30E0      		ldi r19,0
 671 000e 81E0      		ldi r24,lo8(1)
 672 0010 90E0      		ldi r25,0
 673 0012 6230      		cpi r22,lo8(2)
 674 0014 00F4      		brsh .L32
 675 0016 80E0      		ldi r24,0
 676 0018 90E0      		ldi r25,0
 677               	.L32:
 678 001a 8223      		and r24,r18
 679 001c 9323      		and r25,r19
 240:quantum/matrix.c **** 
 680               		.loc 1 240 0
 681 001e 8170      		andi r24,lo8(1)
 682 0020 0895      		ret
 683               		.cfi_endproc
 684               	.LFE17:
 686               		.section	.text.matrix_get_row,"ax",@progbits
 687               	.global	matrix_get_row
 689               	matrix_get_row:
 690               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 691               		.loc 1 244 0
 692               		.cfi_startproc
 693               	.LVL51:
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 0 */
 697               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 698               		.loc 1 250 0
 699 0000 E82F      		mov r30,r24
 700 0002 F0E0      		ldi r31,0
 701 0004 E050      		subi r30,lo8(-(matrix))
 702 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 703               		.loc 1 252 0
 704 0008 8081      		ld r24,Z
 705               	.LVL52:
 706 000a 0895      		ret
 707               		.cfi_endproc
 708               	.LFE18:
 710               		.section	.text.matrix_print,"ax",@progbits
 711               	.global	matrix_print
 713               	matrix_print:
 714               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 715               		.loc 1 255 0
 716               		.cfi_startproc
 717               	/* prologue: function */
 718               	/* frame size = 0 */
 719               	/* stack size = 0 */
 720               	.L__stack_usage = 0
 721               	.LVL53:
 722 0000 0895      		ret
 723               		.cfi_endproc
 724               	.LFE19:
 726               		.section	.text.matrix_key_count,"ax",@progbits
 727               	.global	matrix_key_count
 729               	matrix_key_count:
 730               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 731               		.loc 1 266 0
 732               		.cfi_startproc
 266:quantum/matrix.c ****     uint8_t count = 0;
 733               		.loc 1 266 0
 734 0000 0F93      		push r16
 735               	.LCFI19:
 736               		.cfi_def_cfa_offset 3
 737               		.cfi_offset 16, -2
 738 0002 1F93      		push r17
 739               	.LCFI20:
 740               		.cfi_def_cfa_offset 4
 741               		.cfi_offset 17, -3
 742 0004 CF93      		push r28
 743               	.LCFI21:
 744               		.cfi_def_cfa_offset 5
 745               		.cfi_offset 28, -4
 746 0006 DF93      		push r29
 747               	.LCFI22:
 748               		.cfi_def_cfa_offset 6
 749               		.cfi_offset 29, -5
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 4 */
 753               	.L__stack_usage = 4
 754               	.LVL54:
 266:quantum/matrix.c ****     uint8_t count = 0;
 755               		.loc 1 266 0
 756 0008 C0E0      		ldi r28,lo8(matrix)
 757 000a D0E0      		ldi r29,hi8(matrix)
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 758               		.loc 1 267 0
 759 000c 10E0      		ldi r17,0
 760 000e 0C2F      		mov r16,r28
 761 0010 0B5F      		subi r16,lo8(-(5))
 762               	.LVL55:
 763               	.L36:
 764               	.LBB56:
 269:quantum/matrix.c ****     }
 765               		.loc 1 269 0 discriminator 3
 766 0012 8991      		ld r24,Y+
 767               	.LVL56:
 768 0014 0E94 0000 		call bitpop
 769               	.LVL57:
 770 0018 180F      		add r17,r24
 771               	.LVL58:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 772               		.loc 1 268 0 discriminator 3
 773 001a 0C13      		cpse r16,r28
 774 001c 00C0      		rjmp .L36
 775               	.LBE56:
 272:quantum/matrix.c **** 
 776               		.loc 1 272 0
 777 001e 812F      		mov r24,r17
 778               	/* epilogue start */
 779 0020 DF91      		pop r29
 780 0022 CF91      		pop r28
 781               	.LVL59:
 782 0024 1F91      		pop r17
 783               	.LVL60:
 784 0026 0F91      		pop r16
 785 0028 0895      		ret
 786               		.cfi_endproc
 787               	.LFE20:
 789               		.section	.bss.matrix_debouncing,"aw",@nobits
 792               	matrix_debouncing:
 793 0000 0000 0000 		.zero	5
 793      00
 794               		.section	.bss.matrix_raw,"aw",@nobits
 797               	matrix_raw:
 798 0000 0000 0000 		.zero	5
 798      00
 799               		.section	.bss.matrix,"aw",@nobits
 802               	matrix:
 803 0000 0000 0000 		.zero	5
 803      00
 804               		.section	.rodata.col_pins,"a",@progbits
 807               	col_pins:
 808 0000 31        		.byte	49
 809 0001 33        		.byte	51
 810 0002 32        		.byte	50
 811 0003 36        		.byte	54
 812               		.section	.rodata.row_pins,"a",@progbits
 815               	row_pins:
 816 0000 66        		.byte	102
 817 0001 97        		.byte	-105
 818 0002 C6        		.byte	-58
 819 0003 34        		.byte	52
 820 0004 35        		.byte	53
 821               		.section	.bss.debouncing,"aw",@nobits
 824               	debouncing:
 825 0000 00        		.zero	1
 826               		.section	.bss.debouncing_time,"aw",@nobits
 829               	debouncing_time:
 830 0000 0000      		.zero	2
 831               		.text
 832               	.Letext0:
 833               		.file 3 "/usr/lib/avr/include/stdint.h"
 834               		.file 4 "./tmk_core/common/matrix.h"
 835               		.file 5 "./tmk_core/common/timer.h"
 836               		.file 6 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccLhRzhK.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLhRzhK.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLhRzhK.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLhRzhK.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLhRzhK.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLhRzhK.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccLhRzhK.s:29     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccLhRzhK.s:46     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccLhRzhK.s:63     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccLhRzhK.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccLhRzhK.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccLhRzhK.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccLhRzhK.s:129    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccLhRzhK.s:146    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccLhRzhK.s:815    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccLhRzhK.s:807    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccLhRzhK.s:797    .bss.matrix_raw:0000000000000000 matrix_raw
     /tmp/ccLhRzhK.s:792    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccLhRzhK.s:802    .bss.matrix:0000000000000000 matrix
     /tmp/ccLhRzhK.s:305    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccLhRzhK.s:824    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccLhRzhK.s:829    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccLhRzhK.s:633    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccLhRzhK.s:653    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccLhRzhK.s:689    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccLhRzhK.s:713    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccLhRzhK.s:729    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
